"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.QueuedIteratorImpl = void 0;
const util_1 = require("./util");
const errors_1 = require("./errors");
class QueuedIteratorImpl {
    inflight;
    processed;
    // this is updated by the protocol
    received;
    noIterator;
    iterClosed;
    done;
    signal;
    yields;
    filtered;
    pendingFiltered;
    ctx;
    _data; //data is for use by extenders in any way they like
    err;
    time;
    profile;
    yielding;
    didBreak;
    constructor() {
        this.inflight = 0;
        this.filtered = 0;
        this.pendingFiltered = 0;
        this.processed = 0;
        this.received = 0;
        this.noIterator = false;
        this.done = false;
        this.signal = (0, util_1.deferred)();
        this.yields = [];
        this.iterClosed = (0, util_1.deferred)();
        this.time = 0;
        this.yielding = false;
        this.didBreak = false;
        this.profile = false;
    }
    [Symbol.asyncIterator]() {
        return this.iterate();
    }
    push(v) {
        if (this.done) {
            return;
        }
        // if they `break` from a `for await`, any signaling that is pushed via
        // a function is not handled this can prevent closed promises from
        // resolving downstream.
        if (this.didBreak) {
            if (typeof v === "function") {
                const cb = v;
                try {
                    cb();
                }
                catch (_) {
                    // ignored
                }
            }
            return;
        }
        if (typeof v === "function") {
            this.pendingFiltered++;
        }
        this.yields.push(v);
        this.signal.resolve();
    }
    async *iterate() {
        if (this.noIterator) {
            throw new errors_1.InvalidOperationError("iterator cannot be used when a callback is registered");
        }
        if (this.yielding) {
            throw new errors_1.InvalidOperationError("iterator is already yielding");
        }
        this.yielding = true;
        try {
            while (true) {
                if (this.yields.length === 0) {
                    await this.signal;
                }
                if (this.err) {
                    throw this.err;
                }
                const yields = this.yields;
                this.inflight = yields.length;
                this.yields = [];
                for (let i = 0; i < yields.length; i++) {
                    if (typeof yields[i] === "function") {
                        this.pendingFiltered--;
                        const fn = yields[i];
                        try {
                            fn();
                        }
                        catch (err) {
                            // failed on the invocation - fail the iterator
                            // so they know to fix the callback
                            throw err;
                        }
                        // fn could have also set an error
                        if (this.err) {
                            throw this.err;
                        }
                        continue;
                    }
                    this.processed++;
                    this.inflight--;
                    const start = this.profile ? Date.now() : 0;
                    yield yields[i];
                    this.time = this.profile ? Date.now() - start : 0;
                }
                // yielding could have paused and microtask
                // could have added messages. Prevent allocations
                // if possible
                if (this.done) {
                    break;
                }
                else if (this.yields.length === 0) {
                    yields.length = 0;
                    this.yields = yields;
                    this.signal = (0, util_1.deferred)();
                }
            }
        }
        finally {
            // the iterator used break/return
            this.didBreak = true;
            this.stop();
        }
    }
    stop(err) {
        if (this.done) {
            return;
        }
        this.err = err;
        this.done = true;
        this.signal.resolve();
        this.iterClosed.resolve(err);
    }
    getProcessed() {
        return this.noIterator ? this.received : this.processed;
    }
    getPending() {
        return this.yields.length + this.inflight - this.pendingFiltered;
    }
    getReceived() {
        return this.received - this.filtered;
    }
}
exports.QueuedIteratorImpl = QueuedIteratorImpl;
//# sourceMappingURL=queued_iterator.js.map