"use strict";
/*
 * Copyright 2024 Synadia Communications, Inc
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.errors = exports.PermissionViolationError = exports.NoRespondersError = exports.TimeoutError = exports.RequestError = exports.ProtocolError = exports.ConnectionError = exports.DrainingConnectionError = exports.ClosedConnectionError = exports.AuthorizationError = exports.UserAuthenticationExpiredError = exports.InvalidOperationError = exports.InvalidArgumentError = exports.InvalidSubjectError = void 0;
/**
 * Represents an error that is thrown when an invalid subject is encountered.
 * This class extends the built-in Error object.
 *
 * @class
 * @extends Error
 */
class InvalidSubjectError extends Error {
    constructor(subject, options) {
        super(`illegal subject: '${subject}'`, options);
        this.name = "InvalidSubjectError";
    }
}
exports.InvalidSubjectError = InvalidSubjectError;
class InvalidArgumentError extends Error {
    constructor(message, options) {
        super(message, options);
        this.name = "InvalidArgumentError";
    }
    static format(property, message, options) {
        if (Array.isArray(message) && message.length > 1) {
            message = message[0];
        }
        if (Array.isArray(property)) {
            property = property.map((n) => `'${n}'`);
            property = property.join(",");
        }
        else {
            property = `'${property}'`;
        }
        return new InvalidArgumentError(`${property} ${message}`, options);
    }
}
exports.InvalidArgumentError = InvalidArgumentError;
/**
 * InvalidOperationError is a custom error class that extends the standard Error object.
 * It represents an error that occurs when an invalid operation is attempted on one of
 * objects returned by the API. For example, trying to iterate on an object that was
 * configured with a callback.
 *
 * @class InvalidOperationError
 * @extends {Error}
 *
 * @param {string} message - The error message that explains the reason for the error.
 * @param {ErrorOptions} [options] - Optional parameter to provide additional error options.
 */
class InvalidOperationError extends Error {
    constructor(message, options) {
        super(message, options);
        this.name = "InvalidOperationError";
    }
}
exports.InvalidOperationError = InvalidOperationError;
/**
 * Represents an error indicating that user authentication has expired.
 * This error is typically thrown when a user attempts to access a connection
 * but their authentication credentials have expired.
 */
class UserAuthenticationExpiredError extends Error {
    constructor(message, options) {
        super(message, options);
        this.name = "UserAuthenticationExpiredError";
    }
    static parse(s) {
        const ss = s.toLowerCase();
        if (ss.indexOf("user authentication expired") !== -1) {
            return new UserAuthenticationExpiredError(s);
        }
        return null;
    }
}
exports.UserAuthenticationExpiredError = UserAuthenticationExpiredError;
/**
 * Represents an error related to authorization issues.
 * Note that these could represent an authorization violation,
 * or that the account authentication configuration has expired,
 * or an authentication timeout.
 */
class AuthorizationError extends Error {
    constructor(message, options) {
        super(message, options);
        this.name = "AuthorizationError";
    }
    static parse(s) {
        const messages = [
            "authorization violation",
            "account authentication expired",
            "authentication timeout",
        ];
        const ss = s.toLowerCase();
        for (let i = 0; i < messages.length; i++) {
            if (ss.indexOf(messages[i]) !== -1) {
                return new AuthorizationError(s);
            }
        }
        return null;
    }
}
exports.AuthorizationError = AuthorizationError;
/**
 * Class representing an error thrown when an operation is attempted on a closed connection.
 *
 * This error is intended to signal that a connection-related operation could not be completed
 * because the connection is no longer open or has been terminated.
 *
 * @class
 * @extends Error
 */
class ClosedConnectionError extends Error {
    constructor() {
        super("closed connection");
        this.name = "ClosedConnectionError";
    }
}
exports.ClosedConnectionError = ClosedConnectionError;
/**
 * The `ConnectionDrainingError` class represents a specific type of error
 * that occurs when a connection is being drained.
 *
 * This error is typically used in scenarios where connections need to be
 * gracefully closed or when they are transitioning to an inactive state.
 *
 * The error message is set to "connection draining" and the error name is
 * overridden to "DrainingConnectionError".
 */
class DrainingConnectionError extends Error {
    constructor() {
        super("connection draining");
        this.name = "DrainingConnectionError";
    }
}
exports.DrainingConnectionError = DrainingConnectionError;
/**
 * Represents an error that occurs when a network connection fails.
 * Extends the built-in Error class to provide additional context for connection-related issues.
 *
 * @param {string} message - A human-readable description of the error.
 * @param {ErrorOptions} [options] - Optional settings for customizing the error behavior.
 */
class ConnectionError extends Error {
    constructor(message, options) {
        super(message, options);
        this.name = "ConnectionError";
    }
}
exports.ConnectionError = ConnectionError;
/**
 * Represents an error encountered during protocol operations.
 * This class extends the built-in `Error` class, providing a specific
 * error type called `ProtocolError`.
 *
 * @param {string} message - A descriptive message describing the error.
 * @param {ErrorOptions} [options] - Optional parameters to include additional details.
 */
class ProtocolError extends Error {
    constructor(message, options) {
        super(message, options);
        this.name = "ProtocolError";
    }
}
exports.ProtocolError = ProtocolError;
/**
 * Class representing an error that occurs during an request operation
 * (such as TimeoutError, or NoRespondersError, or some other error).
 *
 * @extends Error
 */
class RequestError extends Error {
    constructor(message = "", options) {
        super(message, options);
        this.name = "RequestError";
    }
    isNoResponders() {
        return this.cause instanceof NoRespondersError;
    }
}
exports.RequestError = RequestError;
/**
 * TimeoutError is a custom error class that extends the built-in Error class.
 * It is used to represent an error that occurs when an operation exceeds a
 * predefined time limit.
 *
 * @class
 * @extends {Error}
 */
class TimeoutError extends Error {
    constructor(options) {
        super("timeout", options);
        this.name = "TimeoutError";
    }
}
exports.TimeoutError = TimeoutError;
/**
 * NoRespondersError is an error thrown when no responders (no service is
 * subscribing to the subject) are found for a given subject. This error
 * is typically found as the cause for a RequestError
 *
 * @extends Error
 *
 * @param {string} subject - The subject for which no responders were found.
 * @param {ErrorOptions} [options] - Optional error options.
 */
class NoRespondersError extends Error {
    subject;
    constructor(subject, options) {
        super(`no responders: '${subject}'`, options);
        this.subject = subject;
        this.name = "NoResponders";
    }
}
exports.NoRespondersError = NoRespondersError;
/**
 * Class representing a Permission Violation Error.
 * It provides information about the operation (either "publish" or "subscription")
 * and the subject used for the operation and the optional queue (if a subscription).
 *
 * This error is terminal for a subscription.
 */
class PermissionViolationError extends Error {
    operation;
    subject;
    queue;
    constructor(message, operation, subject, queue, options) {
        super(message, options);
        this.name = "PermissionViolationError";
        this.operation = operation;
        this.subject = subject;
        this.queue = queue;
    }
    static parse(s) {
        const t = s ? s.toLowerCase() : "";
        if (t.indexOf("permissions violation") === -1) {
            return null;
        }
        let operation = "publish";
        let subject = "";
        let queue = undefined;
        const m = s.match(/(Publish|Subscription) to "(\S+)"/);
        if (m) {
            operation = m[1].toLowerCase();
            subject = m[2];
            if (operation === "subscription") {
                const qm = s.match(/using queue "(\S+)"/);
                if (qm) {
                    queue = qm[1];
                }
            }
        }
        return new PermissionViolationError(s, operation, subject, queue);
    }
}
exports.PermissionViolationError = PermissionViolationError;
exports.errors = {
    AuthorizationError,
    ClosedConnectionError,
    ConnectionError,
    DrainingConnectionError,
    InvalidArgumentError,
    InvalidOperationError,
    InvalidSubjectError,
    NoRespondersError,
    PermissionViolationError,
    ProtocolError,
    RequestError,
    TimeoutError,
    UserAuthenticationExpiredError,
};
//# sourceMappingURL=errors.js.map