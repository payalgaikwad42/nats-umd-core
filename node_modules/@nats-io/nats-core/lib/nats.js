"use strict";
/*
 * Copyright 2018-2023 The NATS Authors
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.NatsConnectionImpl = void 0;
const util_1 = require("./util");
const protocol_1 = require("./protocol");
const encoders_1 = require("./encoders");
const semver_1 = require("./semver");
const options_1 = require("./options");
const queued_iterator_1 = require("./queued_iterator");
const request_1 = require("./request");
const core_1 = require("./core");
const errors_1 = require("./errors");
class NatsConnectionImpl {
    options;
    protocol;
    draining;
    closeListeners;
    constructor(opts) {
        this.draining = false;
        this.options = (0, options_1.parseOptions)(opts);
    }
    static connect(opts = {}) {
        return new Promise((resolve, reject) => {
            const nc = new NatsConnectionImpl(opts);
            protocol_1.ProtocolHandler.connect(nc.options, nc)
                .then((ph) => {
                nc.protocol = ph;
                resolve(nc);
            })
                .catch((err) => {
                reject(err);
            });
        });
    }
    closed() {
        return this.protocol.closed;
    }
    async close() {
        await this.protocol.close();
    }
    _check(subject, sub, pub) {
        if (this.isClosed()) {
            throw new errors_1.errors.ClosedConnectionError();
        }
        if (sub && this.isDraining()) {
            throw new errors_1.errors.DrainingConnectionError();
        }
        if (pub && this.protocol.noMorePublishing) {
            throw new errors_1.errors.DrainingConnectionError();
        }
        subject = subject || "";
        if (subject.length === 0) {
            throw new errors_1.errors.InvalidSubjectError(subject);
        }
    }
    publish(subject, data, options) {
        this._check(subject, false, true);
        if (options?.reply) {
            this._check(options.reply, false, true);
        }
        this.protocol.publish(subject, data, options);
    }
    publishMessage(msg) {
        return this.publish(msg.subject, msg.data, {
            reply: msg.reply,
            headers: msg.headers,
        });
    }
    respondMessage(msg) {
        if (msg.reply) {
            this.publish(msg.reply, msg.data, {
                reply: msg.reply,
                headers: msg.headers,
            });
            return true;
        }
        return false;
    }
    subscribe(subject, opts = {}) {
        this._check(subject, true, false);
        const sub = new protocol_1.SubscriptionImpl(this.protocol, subject, opts);
        if (typeof opts.callback !== "function" && typeof opts.slow === "number") {
            sub.setSlowNotificationFn(opts.slow, (pending) => {
                this.protocol.dispatchStatus({
                    type: "slowConsumer",
                    sub,
                    pending,
                });
            });
        }
        this.protocol.subscribe(sub);
        return sub;
    }
    _resub(s, subject, max) {
        this._check(subject, true, false);
        const si = s;
        // FIXME: need way of understanding a callbacks processed
        //   count without it, we cannot really do much - ie
        //   for rejected messages, the count would be lower, etc.
        //   To handle cases were for example KV is building a map
        //   the consumer would say how many messages we need to do
        //   a proper build before we can handle updates.
        si.max = max; // this might clear it
        if (max) {
            // we cannot auto-unsub, because we don't know the
            // number of messages we processed vs received
            // allow the auto-unsub on processMsg to work if they
            // we were called with a new max
            si.max = max + si.received;
        }
        this.protocol.resub(si, subject);
    }
    // possibilities are:
    // stop on error or any non-100 status
    // AND:
    // - wait for timer
    // - wait for n messages or timer
    // - wait for unknown messages, done when empty or reset timer expires (with possible alt wait)
    // - wait for unknown messages, done when an empty payload is received or timer expires (with possible alt wait)
    requestMany(subject, data = encoders_1.Empty, opts = { maxWait: 1000, maxMessages: -1 }) {
        const asyncTraces = !(this.protocol.options.noAsyncTraces || false);
        try {
            this._check(subject, true, true);
        }
        catch (err) {
            return Promise.reject(err);
        }
        opts.strategy = opts.strategy || "timer";
        opts.maxWait = opts.maxWait || 1000;
        if (opts.maxWait < 1) {
            return Promise.reject(errors_1.InvalidArgumentError.format("timeout", "must be greater than 0"));
        }
        // the iterator for user results
        const qi = new queued_iterator_1.QueuedIteratorImpl();
        function stop(err) {
            qi.push(() => {
                qi.stop(err);
            });
        }
        // callback for the subscription or the mux handler
        // simply pushes errors and messages into the iterator
        function callback(err, msg) {
            if (err || msg === null) {
                stop(err === null ? undefined : err);
            }
            else {
                qi.push(msg);
            }
        }
        if (opts.noMux) {
            // we setup a subscription and manage it
            const stack = asyncTraces ? new Error().stack : null;
            let max = typeof opts.maxMessages === "number" && opts.maxMessages > 0
                ? opts.maxMessages
                : -1;
            const sub = this.subscribe((0, core_1.createInbox)(this.options.inboxPrefix), {
                callback: (err, msg) => {
                    // we only expect runtime errors or a no responders
                    if (msg?.data?.length === 0 &&
                        msg?.headers?.status === "503") {
                        err = new errors_1.errors.NoRespondersError(subject);
                    }
                    // augment any error with the current stack to provide context
                    // for the error on the suer code
                    if (err) {
                        if (stack) {
                            err.stack += `\n\n${stack}`;
                        }
                        cancel(err);
                        return;
                    }
                    // push the message
                    callback(null, msg);
                    // see if the m request is completed
                    if (opts.strategy === "count") {
                        max--;
                        if (max === 0) {
                            cancel();
                        }
                    }
                    if (opts.strategy === "stall") {
                        clearTimers();
                        timer = setTimeout(() => {
                            cancel();
                        }, 300);
                    }
                    if (opts.strategy === "sentinel") {
                        if (msg && msg.data.length === 0) {
                            cancel();
                        }
                    }
                },
            });
            sub.requestSubject = subject;
            sub.closed
                .then(() => {
                stop();
            })
                .catch((err) => {
                qi.stop(err);
            });
            const cancel = (err) => {
                if (err) {
                    qi.push(() => {
                        throw err;
                    });
                }
                clearTimers();
                sub.drain()
                    .then(() => {
                    stop();
                })
                    .catch((_err) => {
                    stop();
                });
            };
            qi.iterClosed
                .then(() => {
                clearTimers();
                sub?.unsubscribe();
            })
                .catch((_err) => {
                clearTimers();
                sub?.unsubscribe();
            });
            try {
                this.publish(subject, data, { reply: sub.getSubject() });
            }
            catch (err) {
                cancel(err);
            }
            let timer = setTimeout(() => {
                cancel();
            }, opts.maxWait);
            const clearTimers = () => {
                if (timer) {
                    clearTimeout(timer);
                }
            };
        }
        else {
            // the ingestion is the RequestMany
            const rmo = opts;
            rmo.callback = callback;
            qi.iterClosed.then(() => {
                r.cancel();
            }).catch((err) => {
                r.cancel(err);
            });
            const r = new request_1.RequestMany(this.protocol.muxSubscriptions, subject, rmo);
            this.protocol.request(r);
            try {
                this.publish(subject, data, {
                    reply: `${this.protocol.muxSubscriptions.baseInbox}${r.token}`,
                    headers: opts.headers,
                });
            }
            catch (err) {
                r.cancel(err);
            }
        }
        return Promise.resolve(qi);
    }
    request(subject, data, opts = { timeout: 1000, noMux: false }) {
        try {
            this._check(subject, true, true);
        }
        catch (err) {
            return Promise.reject(err);
        }
        const asyncTraces = !(this.protocol.options.noAsyncTraces || false);
        opts.timeout = opts.timeout || 1000;
        if (opts.timeout < 1) {
            return Promise.reject(errors_1.InvalidArgumentError.format("timeout", `must be greater than 0`));
        }
        if (!opts.noMux && opts.reply) {
            return Promise.reject(errors_1.InvalidArgumentError.format(["reply", "noMux"], "are mutually exclusive"));
        }
        if (opts.noMux) {
            const inbox = opts.reply
                ? opts.reply
                : (0, core_1.createInbox)(this.options.inboxPrefix);
            const d = (0, util_1.deferred)();
            const errCtx = asyncTraces ? new errors_1.errors.RequestError("") : null;
            const sub = this.subscribe(inbox, {
                max: 1,
                timeout: opts.timeout,
                callback: (err, msg) => {
                    // check for no responders status
                    if (msg && msg.data?.length === 0 && msg.headers?.code === 503) {
                        err = new errors_1.errors.NoRespondersError(subject);
                    }
                    if (err) {
                        // we have a proper stack on timeout
                        if (!(err instanceof errors_1.TimeoutError)) {
                            if (errCtx) {
                                errCtx.message = err.message;
                                errCtx.cause = err;
                                err = errCtx;
                            }
                            else {
                                err = new errors_1.errors.RequestError(err.message, { cause: err });
                            }
                        }
                        d.reject(err);
                        sub.unsubscribe();
                    }
                    else {
                        d.resolve(msg);
                    }
                },
            });
            sub.requestSubject = subject;
            this.protocol.publish(subject, data, {
                reply: inbox,
                headers: opts.headers,
            });
            return d;
        }
        else {
            const r = new request_1.RequestOne(this.protocol.muxSubscriptions, subject, opts, asyncTraces);
            this.protocol.request(r);
            try {
                this.publish(subject, data, {
                    reply: `${this.protocol.muxSubscriptions.baseInbox}${r.token}`,
                    headers: opts.headers,
                });
            }
            catch (err) {
                r.cancel(err);
            }
            const p = Promise.race([r.timer, r.deferred]);
            p.catch(() => {
                r.cancel();
            });
            return p;
        }
    }
    /** *
     * Flushes to the server. Promise resolves when round-trip completes.
     * @returns {Promise<void>}
     */
    flush() {
        if (this.isClosed()) {
            return Promise.reject(new errors_1.errors.ClosedConnectionError());
        }
        return this.protocol.flush();
    }
    drain() {
        if (this.isClosed()) {
            return Promise.reject(new errors_1.errors.ClosedConnectionError());
        }
        if (this.isDraining()) {
            return Promise.reject(new errors_1.errors.DrainingConnectionError());
        }
        this.draining = true;
        return this.protocol.drain();
    }
    isClosed() {
        return this.protocol.isClosed();
    }
    isDraining() {
        return this.draining;
    }
    getServer() {
        const srv = this.protocol.getServer();
        return srv ? srv.listen : "";
    }
    status() {
        const iter = new queued_iterator_1.QueuedIteratorImpl();
        iter.iterClosed.then(() => {
            const idx = this.protocol.listeners.indexOf(iter);
            if (idx > -1) {
                this.protocol.listeners.splice(idx, 1);
            }
        });
        this.protocol.listeners.push(iter);
        return iter;
    }
    get info() {
        return this.protocol.isClosed() ? undefined : this.protocol.info;
    }
    async context() {
        const r = await this.request(`$SYS.REQ.USER.INFO`);
        return r.json((key, value) => {
            if (key === "time") {
                return new Date(Date.parse(value));
            }
            return value;
        });
    }
    stats() {
        return {
            inBytes: this.protocol.inBytes,
            outBytes: this.protocol.outBytes,
            inMsgs: this.protocol.inMsgs,
            outMsgs: this.protocol.outMsgs,
        };
    }
    getServerVersion() {
        const info = this.info;
        return info ? (0, semver_1.parseSemVer)(info.version) : undefined;
    }
    async rtt() {
        if (this.isClosed()) {
            throw new errors_1.errors.ClosedConnectionError();
        }
        if (!this.protocol.connected) {
            throw new errors_1.errors.RequestError("connection disconnected");
        }
        const start = Date.now();
        await this.flush();
        return Date.now() - start;
    }
    get features() {
        return this.protocol.features;
    }
    reconnect() {
        if (this.isClosed()) {
            return Promise.reject(new errors_1.errors.ClosedConnectionError());
        }
        if (this.isDraining()) {
            return Promise.reject(new errors_1.errors.DrainingConnectionError());
        }
        return this.protocol.reconnect();
    }
    // internal
    addCloseListener(listener) {
        if (this.closeListeners === undefined) {
            this.closeListeners = new CloseListeners(this.closed());
        }
        this.closeListeners.add(listener);
    }
    // internal
    removeCloseListener(listener) {
        if (this.closeListeners) {
            this.closeListeners.remove(listener);
        }
    }
}
exports.NatsConnectionImpl = NatsConnectionImpl;
class CloseListeners {
    listeners;
    constructor(closed) {
        this.listeners = [];
        closed.then((err) => {
            this.notify(err);
        });
    }
    add(listener) {
        this.listeners.push(listener);
    }
    remove(listener) {
        this.listeners = this.listeners.filter((l) => l !== listener);
    }
    notify(err) {
        this.listeners.forEach((l) => {
            if (typeof l.connectionClosedCallback === "function") {
                try {
                    l.connectionClosedCallback(err);
                }
                catch (_) {
                    // ignored
                }
            }
        });
        this.listeners = [];
    }
}
//# sourceMappingURL=nats.js.map