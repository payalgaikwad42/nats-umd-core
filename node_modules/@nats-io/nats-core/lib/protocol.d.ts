import type { Transport } from "./transport";
import type { Deferred, Delay, Timeout } from "./util";
import { DataBuffer } from "./databuffer";
import type { ServerImpl } from "./servers";
import { Servers } from "./servers";
import { QueuedIteratorImpl } from "./queued_iterator";
import { MuxSubscription } from "./muxsubscription";
import { Heartbeat } from "./heartbeats";
import type { MsgArg, ParserEvent } from "./parser";
import { Parser } from "./parser";
import { Features } from "./semver";
import type { ConnectionOptions, Dispatcher, Msg, Payload, Publisher, PublishOptions, Request, Server, ServerInfo, Status, Subscription, SubscriptionOptions } from "./core";
import type { AuthorizationError, PermissionViolationError, UserAuthenticationExpiredError } from "./errors";
export declare const INFO: RegExp;
export declare class Connect {
    echo?: boolean;
    no_responders?: boolean;
    protocol: number;
    verbose?: boolean;
    pedantic?: boolean;
    jwt?: string;
    nkey?: string;
    sig?: string;
    user?: string;
    pass?: string;
    auth_token?: string;
    tls_required?: boolean;
    name?: string;
    lang: string;
    version: string;
    headers?: boolean;
    constructor(transport: {
        version: string;
        lang: string;
    }, opts: ConnectionOptions, nonce?: string);
}
declare class SlowNotifier {
    slow: number;
    cb: (pending: number) => void;
    notified: boolean;
    constructor(slow: number, cb: (pending: number) => void);
    maybeNotify(pending: number): void;
}
export declare class SubscriptionImpl extends QueuedIteratorImpl<Msg> implements Subscription {
    sid: number;
    queue?: string;
    draining: boolean;
    max?: number;
    subject: string;
    drained?: Promise<void>;
    protocol: ProtocolHandler;
    timer?: Timeout<void>;
    info?: unknown;
    cleanupFn?: (sub: Subscription, info?: unknown) => void;
    closed: Deferred<void | Error>;
    requestSubject?: string;
    slow?: SlowNotifier;
    constructor(protocol: ProtocolHandler, subject: string, opts?: SubscriptionOptions);
    setSlowNotificationFn(slow: number, fn?: (pending: number) => void): void;
    callback(err: Error | null, msg: Msg): void;
    close(err?: Error): void;
    unsubscribe(max?: number): void;
    cancelTimeout(): void;
    drain(): Promise<void>;
    isDraining(): boolean;
    isClosed(): boolean;
    getSubject(): string;
    getMax(): number | undefined;
    getID(): number;
}
export declare class Subscriptions {
    mux: SubscriptionImpl | null;
    subs: Map<number, SubscriptionImpl>;
    sidCounter: number;
    constructor();
    size(): number;
    add(s: SubscriptionImpl): SubscriptionImpl;
    setMux(s: SubscriptionImpl | null): SubscriptionImpl | null;
    getMux(): SubscriptionImpl | null;
    get(sid: number): SubscriptionImpl | undefined;
    resub(s: SubscriptionImpl): SubscriptionImpl;
    all(): (SubscriptionImpl)[];
    cancel(s: SubscriptionImpl): void;
    handleError(err: PermissionViolationError): boolean;
    close(): void;
}
export declare class ProtocolHandler implements Dispatcher<ParserEvent> {
    connected: boolean;
    connectedOnce: boolean;
    infoReceived: boolean;
    info?: ServerInfo;
    muxSubscriptions: MuxSubscription;
    options: ConnectionOptions;
    outbound: DataBuffer;
    pongs: Array<Deferred<void>>;
    subscriptions: Subscriptions;
    transport: Transport;
    noMorePublishing: boolean;
    connectError?: (err?: Error) => void;
    publisher: Publisher;
    _closed: boolean;
    closed: Deferred<Error | void>;
    listeners: QueuedIteratorImpl<Status>[];
    heartbeats: Heartbeat;
    parser: Parser;
    outMsgs: number;
    inMsgs: number;
    outBytes: number;
    inBytes: number;
    pendingLimit: number;
    lastError?: Error;
    abortReconnect: boolean;
    whyClosed: string;
    servers: Servers;
    server: ServerImpl;
    features: Features;
    connectPromise: Promise<void> | null;
    dialDelay: Delay | null;
    raceTimer?: Timeout<void>;
    constructor(options: ConnectionOptions, publisher: Publisher);
    resetOutbound(): void;
    dispatchStatus(status: Status): void;
    private prepare;
    disconnect(): void;
    reconnect(): Promise<void>;
    disconnected(err?: Error): Promise<void>;
    dial(srv: Server): Promise<void>;
    _doDial(srv: Server): Promise<void>;
    dialLoop(): Promise<void>;
    dodialLoop(): Promise<void>;
    static connect(options: ConnectionOptions, publisher: Publisher): Promise<ProtocolHandler>;
    static toError(s: string): Error;
    processMsg(msg: MsgArg, data: Uint8Array): void;
    processError(m: Uint8Array): void;
    handleError(err: Error): void;
    handleAuthError(err: UserAuthenticationExpiredError | AuthorizationError): void;
    processPing(): void;
    processPong(): void;
    processInfo(m: Uint8Array): void;
    push(e: ParserEvent): void;
    sendCommand(cmd: string | Uint8Array, ...payloads: Uint8Array[]): void;
    publish(subject: string, payload?: Payload, options?: PublishOptions): void;
    request(r: Request): Request;
    subscribe(s: SubscriptionImpl): Subscription;
    _sub(s: SubscriptionImpl): void;
    _subunsub(s: SubscriptionImpl): SubscriptionImpl;
    unsubscribe(s: SubscriptionImpl, max?: number): void;
    unsub(s: SubscriptionImpl, max?: number): void;
    resub(s: SubscriptionImpl, subject: string): void;
    flush(p?: Deferred<void>): Promise<void>;
    sendSubscriptions(): void;
    close(err?: Error): Promise<void>;
    isClosed(): boolean;
    drain(): Promise<void>;
    private flushPending;
    private initMux;
    private selectServer;
    getServer(): ServerImpl | undefined;
}
export {};
