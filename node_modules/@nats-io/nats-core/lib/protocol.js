"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProtocolHandler = exports.Subscriptions = exports.SubscriptionImpl = exports.Connect = exports.INFO = void 0;
/*
 * Copyright 2018-2024 The NATS Authors
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const encoders_1 = require("./encoders");
const transport_1 = require("./transport");
const util_1 = require("./util");
const databuffer_1 = require("./databuffer");
const servers_1 = require("./servers");
const queued_iterator_1 = require("./queued_iterator");
const muxsubscription_1 = require("./muxsubscription");
const heartbeats_1 = require("./heartbeats");
const parser_1 = require("./parser");
const msg_1 = require("./msg");
const semver_1 = require("./semver");
const options_1 = require("./options");
const errors_1 = require("./errors");
const FLUSH_THRESHOLD = 1024 * 32;
exports.INFO = /^INFO\s+([^\r\n]+)\r\n/i;
const PONG_CMD = (0, encoders_1.encode)("PONG\r\n");
const PING_CMD = (0, encoders_1.encode)("PING\r\n");
class Connect {
    echo;
    no_responders;
    protocol;
    verbose;
    pedantic;
    jwt;
    nkey;
    sig;
    user;
    pass;
    auth_token;
    tls_required;
    name;
    lang;
    version;
    headers;
    constructor(transport, opts, nonce) {
        this.protocol = 1;
        this.version = transport.version;
        this.lang = transport.lang;
        this.echo = opts.noEcho ? false : undefined;
        this.verbose = opts.verbose;
        this.pedantic = opts.pedantic;
        this.tls_required = opts.tls ? true : undefined;
        this.name = opts.name;
        const creds = (opts && typeof opts.authenticator === "function"
            ? opts.authenticator(nonce)
            : {}) || {};
        (0, util_1.extend)(this, creds);
    }
}
exports.Connect = Connect;
class SlowNotifier {
    slow;
    cb;
    notified;
    constructor(slow, cb) {
        this.slow = slow;
        this.cb = cb;
        this.notified = false;
    }
    maybeNotify(pending) {
        // if we are below the threshold reset the ability to notify
        if (pending <= this.slow) {
            this.notified = false;
        }
        else {
            if (!this.notified) {
                // crossed the threshold, notify and silence.
                this.cb(pending);
                this.notified = true;
            }
        }
    }
}
class SubscriptionImpl extends queued_iterator_1.QueuedIteratorImpl {
    sid;
    queue;
    draining;
    max;
    subject;
    drained;
    protocol;
    timer;
    info;
    cleanupFn;
    closed;
    requestSubject;
    slow;
    constructor(protocol, subject, opts = {}) {
        super();
        (0, util_1.extend)(this, opts);
        this.protocol = protocol;
        this.subject = subject;
        this.draining = false;
        this.noIterator = typeof opts.callback === "function";
        this.closed = (0, util_1.deferred)();
        const asyncTraces = !(protocol.options?.noAsyncTraces || false);
        if (opts.timeout) {
            this.timer = (0, util_1.timeout)(opts.timeout, asyncTraces);
            this.timer
                .then(() => {
                // timer was cancelled
                this.timer = undefined;
            })
                .catch((err) => {
                // timer fired
                this.stop(err);
                if (this.noIterator) {
                    this.callback(err, {});
                }
            });
        }
        if (!this.noIterator) {
            // cleanup - they used break or return from the iterator
            // make sure we clean up, if they didn't call unsub
            this.iterClosed.then((err) => {
                this.closed.resolve(err);
                this.unsubscribe();
            });
        }
    }
    setSlowNotificationFn(slow, fn) {
        this.slow = undefined;
        if (fn) {
            if (this.noIterator) {
                throw new Error("callbacks don't support slow notifications");
            }
            this.slow = new SlowNotifier(slow, fn);
        }
    }
    callback(err, msg) {
        this.cancelTimeout();
        err ? this.stop(err) : this.push(msg);
        if (!err && this.slow) {
            this.slow.maybeNotify(this.getPending());
        }
    }
    close(err) {
        if (!this.isClosed()) {
            this.cancelTimeout();
            const fn = () => {
                this.stop();
                if (this.cleanupFn) {
                    try {
                        this.cleanupFn(this, this.info);
                    }
                    catch (_err) {
                        // ignoring
                    }
                }
                this.closed.resolve(err);
            };
            if (this.noIterator) {
                fn();
            }
            else {
                this.push(fn);
            }
        }
    }
    unsubscribe(max) {
        this.protocol.unsubscribe(this, max);
    }
    cancelTimeout() {
        if (this.timer) {
            this.timer.cancel();
            this.timer = undefined;
        }
    }
    drain() {
        if (this.protocol.isClosed()) {
            return Promise.reject(new errors_1.errors.ClosedConnectionError());
        }
        if (this.isClosed()) {
            return Promise.reject(new errors_1.errors.InvalidOperationError("subscription is already closed"));
        }
        if (!this.drained) {
            this.draining = true;
            this.protocol.unsub(this);
            this.drained = this.protocol.flush((0, util_1.deferred)())
                .then(() => {
                this.protocol.subscriptions.cancel(this);
            })
                .catch(() => {
                this.protocol.subscriptions.cancel(this);
            });
        }
        return this.drained;
    }
    isDraining() {
        return this.draining;
    }
    isClosed() {
        return this.done;
    }
    getSubject() {
        return this.subject;
    }
    getMax() {
        return this.max;
    }
    getID() {
        return this.sid;
    }
}
exports.SubscriptionImpl = SubscriptionImpl;
class Subscriptions {
    mux;
    subs;
    sidCounter;
    constructor() {
        this.sidCounter = 0;
        this.mux = null;
        this.subs = new Map();
    }
    size() {
        return this.subs.size;
    }
    add(s) {
        this.sidCounter++;
        s.sid = this.sidCounter;
        this.subs.set(s.sid, s);
        return s;
    }
    setMux(s) {
        this.mux = s;
        return s;
    }
    getMux() {
        return this.mux;
    }
    get(sid) {
        return this.subs.get(sid);
    }
    resub(s) {
        this.sidCounter++;
        this.subs.delete(s.sid);
        s.sid = this.sidCounter;
        this.subs.set(s.sid, s);
        return s;
    }
    all() {
        return Array.from(this.subs.values());
    }
    cancel(s) {
        if (s) {
            s.close();
            this.subs.delete(s.sid);
        }
    }
    handleError(err) {
        const subs = this.all();
        let sub;
        if (err.operation === "subscription") {
            sub = subs.find((s) => {
                return s.subject === err.subject && s.queue === err.queue;
            });
        }
        else if (err.operation === "publish") {
            // we have a no mux subscription
            sub = subs.find((s) => {
                return s.requestSubject === err.subject;
            });
        }
        if (sub) {
            sub.callback(err, {});
            sub.close(err);
            this.subs.delete(sub.sid);
            return sub !== this.mux;
        }
        return false;
    }
    close() {
        this.subs.forEach((sub) => {
            sub.close();
        });
    }
}
exports.Subscriptions = Subscriptions;
class ProtocolHandler {
    connected;
    connectedOnce;
    infoReceived;
    info;
    muxSubscriptions;
    options;
    outbound;
    pongs;
    subscriptions;
    transport;
    noMorePublishing;
    connectError;
    publisher;
    _closed;
    closed;
    listeners;
    heartbeats;
    parser;
    outMsgs;
    inMsgs;
    outBytes;
    inBytes;
    pendingLimit;
    lastError;
    abortReconnect;
    whyClosed;
    servers;
    server;
    features;
    connectPromise;
    dialDelay;
    raceTimer;
    constructor(options, publisher) {
        this._closed = false;
        this.connected = false;
        this.connectedOnce = false;
        this.infoReceived = false;
        this.noMorePublishing = false;
        this.abortReconnect = false;
        this.listeners = [];
        this.pendingLimit = FLUSH_THRESHOLD;
        this.outMsgs = 0;
        this.inMsgs = 0;
        this.outBytes = 0;
        this.inBytes = 0;
        this.options = options;
        this.publisher = publisher;
        this.subscriptions = new Subscriptions();
        this.muxSubscriptions = new muxsubscription_1.MuxSubscription();
        this.outbound = new databuffer_1.DataBuffer();
        this.pongs = [];
        this.whyClosed = "";
        //@ts-ignore: options.pendingLimit is hidden
        this.pendingLimit = options.pendingLimit || this.pendingLimit;
        this.features = new semver_1.Features({ major: 0, minor: 0, micro: 0 });
        this.connectPromise = null;
        this.dialDelay = null;
        const servers = typeof options.servers === "string"
            ? [options.servers]
            : options.servers;
        this.servers = new servers_1.Servers(servers, {
            randomize: !options.noRandomize,
        });
        this.closed = (0, util_1.deferred)();
        this.parser = new parser_1.Parser(this);
        this.heartbeats = new heartbeats_1.Heartbeat(this, this.options.pingInterval || options_1.DEFAULT_PING_INTERVAL, this.options.maxPingOut || options_1.DEFAULT_MAX_PING_OUT);
    }
    resetOutbound() {
        this.outbound.reset();
        const pongs = this.pongs;
        this.pongs = [];
        // reject the pongs - the disconnect from here shouldn't have a trace
        // because that confuses API consumers
        const err = new errors_1.errors.RequestError("connection disconnected");
        err.stack = "";
        pongs.forEach((p) => {
            p.reject(err);
        });
        this.parser = new parser_1.Parser(this);
        this.infoReceived = false;
    }
    dispatchStatus(status) {
        this.listeners.forEach((q) => {
            q.push(status);
        });
    }
    prepare() {
        if (this.transport) {
            this.transport.discard();
        }
        this.info = undefined;
        this.resetOutbound();
        const pong = (0, util_1.deferred)();
        pong.catch(() => {
            // provide at least one catch - as pong rejection can happen before it is expected
        });
        this.pongs.unshift(pong);
        this.connectError = (err) => {
            pong.reject(err);
        };
        this.transport = (0, transport_1.newTransport)();
        this.transport.closed()
            .then(async (_err) => {
            this.connected = false;
            if (!this.isClosed()) {
                // if the transport gave an error use that, otherwise
                // we may have received a protocol error
                await this.disconnected(this.transport.closeError || this.lastError);
                return;
            }
        });
        return pong;
    }
    disconnect() {
        this.dispatchStatus({ type: "staleConnection" });
        this.transport.disconnect();
    }
    reconnect() {
        if (this.connected) {
            this.dispatchStatus({
                type: "forceReconnect",
            });
            this.transport.disconnect();
        }
        return Promise.resolve();
    }
    async disconnected(err) {
        this.dispatchStatus({
            type: "disconnect",
            server: this.servers.getCurrentServer().toString(),
        });
        if (this.options.reconnect) {
            await this.dialLoop()
                .then(() => {
                this.dispatchStatus({
                    type: "reconnect",
                    server: this.servers.getCurrentServer().toString(),
                });
                // if we are here we reconnected, but we have an authentication
                // that expired, we need to clean it up, otherwise we'll queue up
                // two of these, and the default for the client will be to
                // close, rather than attempt again - possibly they have an
                // authenticator that dynamically updates
                if (this.lastError instanceof errors_1.errors.UserAuthenticationExpiredError) {
                    this.lastError = undefined;
                }
            })
                .catch((err) => {
                this.close(err).catch();
            });
        }
        else {
            await this.close(err).catch();
        }
    }
    async dial(srv) {
        const pong = this.prepare();
        try {
            this.raceTimer = (0, util_1.timeout)(this.options.timeout || 20000);
            const cp = this.transport.connect(srv, this.options);
            await Promise.race([cp, this.raceTimer]);
            (async () => {
                try {
                    for await (const b of this.transport) {
                        this.parser.parse(b);
                    }
                }
                catch (err) {
                    console.log("reader closed", err);
                }
            })().then();
        }
        catch (err) {
            pong.reject(err);
        }
        try {
            await Promise.race([this.raceTimer, pong]);
            this.raceTimer?.cancel();
            this.connected = true;
            this.connectError = undefined;
            this.sendSubscriptions();
            this.connectedOnce = true;
            this.server.didConnect = true;
            this.server.reconnects = 0;
            this.flushPending();
            this.heartbeats.start();
        }
        catch (err) {
            this.raceTimer?.cancel();
            await this.transport.close(err);
            throw err;
        }
    }
    async _doDial(srv) {
        const { resolve } = this.options;
        const alts = await srv.resolve({
            fn: (0, transport_1.getResolveFn)(),
            debug: this.options.debug,
            randomize: !this.options.noRandomize,
            resolve,
        });
        let lastErr = null;
        for (const a of alts) {
            try {
                lastErr = null;
                this.dispatchStatus({ type: "reconnecting" });
                await this.dial(a);
                // if here we connected
                return;
            }
            catch (err) {
                lastErr = err;
            }
        }
        // if we are here, we failed, and we have no additional
        // alternatives for this server
        throw lastErr;
    }
    dialLoop() {
        if (this.connectPromise === null) {
            this.connectPromise = this.dodialLoop();
            this.connectPromise
                .then(() => { })
                .catch(() => { })
                .finally(() => {
                this.connectPromise = null;
            });
        }
        return this.connectPromise;
    }
    async dodialLoop() {
        let lastError;
        while (true) {
            if (this._closed) {
                // if we are disconnected, and close is called, the client
                // still tries to reconnect - to match the reconnect policy
                // in the case of close, want to stop.
                this.servers.clear();
            }
            const wait = this.options.reconnectDelayHandler
                ? this.options.reconnectDelayHandler()
                : options_1.DEFAULT_RECONNECT_TIME_WAIT;
            let maxWait = wait;
            const srv = this.selectServer();
            if (!srv || this.abortReconnect) {
                if (lastError) {
                    throw lastError;
                }
                else if (this.lastError) {
                    throw this.lastError;
                }
                else {
                    throw new errors_1.errors.ConnectionError("connection refused");
                }
            }
            const now = Date.now();
            if (srv.lastConnect === 0 || srv.lastConnect + wait <= now) {
                srv.lastConnect = Date.now();
                try {
                    await this._doDial(srv);
                    break;
                }
                catch (err) {
                    lastError = err;
                    if (!this.connectedOnce) {
                        if (this.options.waitOnFirstConnect) {
                            continue;
                        }
                        this.servers.removeCurrentServer();
                    }
                    srv.reconnects++;
                    const mra = this.options.maxReconnectAttempts || 0;
                    if (mra !== -1 && srv.reconnects >= mra) {
                        this.servers.removeCurrentServer();
                    }
                }
            }
            else {
                maxWait = Math.min(maxWait, srv.lastConnect + wait - now);
                this.dialDelay = (0, util_1.delay)(maxWait);
                await this.dialDelay;
            }
        }
    }
    static async connect(options, publisher) {
        const h = new ProtocolHandler(options, publisher);
        await h.dialLoop();
        return h;
    }
    static toError(s) {
        let err = errors_1.errors.PermissionViolationError.parse(s);
        if (err) {
            return err;
        }
        err = errors_1.errors.UserAuthenticationExpiredError.parse(s);
        if (err) {
            return err;
        }
        err = errors_1.errors.AuthorizationError.parse(s);
        if (err) {
            return err;
        }
        return new errors_1.errors.ProtocolError(s);
    }
    processMsg(msg, data) {
        this.inMsgs++;
        this.inBytes += data.length;
        if (!this.subscriptions.sidCounter) {
            return;
        }
        const sub = this.subscriptions.get(msg.sid);
        if (!sub) {
            return;
        }
        sub.received += 1;
        if (sub.callback) {
            sub.callback(null, new msg_1.MsgImpl(msg, data, this));
        }
        if (sub.max !== undefined && sub.received >= sub.max) {
            sub.unsubscribe();
        }
    }
    processError(m) {
        let s = (0, encoders_1.decode)(m);
        if (s.startsWith("'") && s.endsWith("'")) {
            s = s.slice(1, s.length - 1);
        }
        const err = ProtocolHandler.toError(s);
        switch (err.constructor) {
            case errors_1.errors.PermissionViolationError: {
                const pe = err;
                const mux = this.subscriptions.getMux();
                const isMuxPermission = mux ? pe.subject === mux.subject : false;
                this.subscriptions.handleError(pe);
                this.muxSubscriptions.handleError(isMuxPermission, pe);
                if (isMuxPermission) {
                    // remove the permission - enable it to be recreated
                    this.subscriptions.setMux(null);
                }
            }
        }
        this.dispatchStatus({ type: "error", error: err });
        this.handleError(err);
    }
    handleError(err) {
        if (err instanceof errors_1.errors.UserAuthenticationExpiredError ||
            err instanceof errors_1.errors.AuthorizationError) {
            this.handleAuthError(err);
        }
        if (!(err instanceof errors_1.errors.PermissionViolationError)) {
            this.lastError = err;
        }
    }
    handleAuthError(err) {
        if ((this.lastError instanceof errors_1.errors.UserAuthenticationExpiredError ||
            this.lastError instanceof errors_1.errors.AuthorizationError) &&
            this.options.ignoreAuthErrorAbort === false) {
            this.abortReconnect = true;
        }
        if (this.connectError) {
            this.connectError(err);
        }
        else {
            this.disconnect();
        }
    }
    processPing() {
        this.transport.send(PONG_CMD);
    }
    processPong() {
        const cb = this.pongs.shift();
        if (cb) {
            cb.resolve();
        }
    }
    processInfo(m) {
        const info = JSON.parse((0, encoders_1.decode)(m));
        this.info = info;
        const updates = this.options && this.options.ignoreClusterUpdates
            ? undefined
            : this.servers.update(info, this.transport.isEncrypted());
        if (!this.infoReceived) {
            this.features.update((0, semver_1.parseSemVer)(info.version));
            this.infoReceived = true;
            if (this.transport.isEncrypted()) {
                this.servers.updateTLSName();
            }
            // send connect
            const { version, lang } = this.transport;
            try {
                const c = new Connect({ version, lang }, this.options, info.nonce);
                if (info.headers) {
                    c.headers = true;
                    c.no_responders = true;
                }
                const cs = JSON.stringify(c);
                this.transport.send((0, encoders_1.encode)(`CONNECT ${cs}${transport_1.CR_LF}`));
                this.transport.send(PING_CMD);
            }
            catch (err) {
                // if we are dying here, this is likely some an authenticator blowing up
                this.close(err).catch();
            }
        }
        if (updates) {
            const { added, deleted } = updates;
            this.dispatchStatus({ type: "update", added, deleted });
        }
        const ldm = info.ldm !== undefined ? info.ldm : false;
        if (ldm) {
            this.dispatchStatus({
                type: "ldm",
                server: this.servers.getCurrentServer().toString(),
            });
        }
    }
    push(e) {
        switch (e.kind) {
            case parser_1.Kind.MSG: {
                const { msg, data } = e;
                this.processMsg(msg, data);
                break;
            }
            case parser_1.Kind.OK:
                break;
            case parser_1.Kind.ERR:
                this.processError(e.data);
                break;
            case parser_1.Kind.PING:
                this.processPing();
                break;
            case parser_1.Kind.PONG:
                this.processPong();
                break;
            case parser_1.Kind.INFO:
                this.processInfo(e.data);
                break;
        }
    }
    sendCommand(cmd, ...payloads) {
        const len = this.outbound.length();
        let buf;
        if (typeof cmd === "string") {
            buf = (0, encoders_1.encode)(cmd);
        }
        else {
            buf = cmd;
        }
        this.outbound.fill(buf, ...payloads);
        if (len === 0) {
            queueMicrotask(() => {
                this.flushPending();
            });
        }
        else if (this.outbound.size() >= this.pendingLimit) {
            // flush inline
            this.flushPending();
        }
    }
    publish(subject, payload = encoders_1.Empty, options) {
        let data;
        if (payload instanceof Uint8Array) {
            data = payload;
        }
        else if (typeof payload === "string") {
            data = encoders_1.TE.encode(payload);
        }
        else {
            throw new TypeError("payload types can be strings or Uint8Array");
        }
        let len = data.length;
        options = options || {};
        options.reply = options.reply || "";
        let headers = encoders_1.Empty;
        let hlen = 0;
        if (options.headers) {
            if (this.info && !this.info.headers) {
                errors_1.InvalidArgumentError.format("headers", "are not available on this server");
            }
            const hdrs = options.headers;
            headers = hdrs.encode();
            hlen = headers.length;
            len = data.length + hlen;
        }
        if (this.info && len > this.info.max_payload) {
            throw errors_1.InvalidArgumentError.format("payload", "max_payload size exceeded");
        }
        this.outBytes += len;
        this.outMsgs++;
        let proto;
        if (options.headers) {
            if (options.reply) {
                proto = `HPUB ${subject} ${options.reply} ${hlen} ${len}\r\n`;
            }
            else {
                proto = `HPUB ${subject} ${hlen} ${len}\r\n`;
            }
            this.sendCommand(proto, headers, data, transport_1.CRLF);
        }
        else {
            if (options.reply) {
                proto = `PUB ${subject} ${options.reply} ${len}\r\n`;
            }
            else {
                proto = `PUB ${subject} ${len}\r\n`;
            }
            this.sendCommand(proto, data, transport_1.CRLF);
        }
    }
    request(r) {
        this.initMux();
        this.muxSubscriptions.add(r);
        return r;
    }
    subscribe(s) {
        this.subscriptions.add(s);
        this._subunsub(s);
        return s;
    }
    _sub(s) {
        if (s.queue) {
            this.sendCommand(`SUB ${s.subject} ${s.queue} ${s.sid}\r\n`);
        }
        else {
            this.sendCommand(`SUB ${s.subject} ${s.sid}\r\n`);
        }
    }
    _subunsub(s) {
        this._sub(s);
        if (s.max) {
            this.unsubscribe(s, s.max);
        }
        return s;
    }
    unsubscribe(s, max) {
        this.unsub(s, max);
        if (s.max === undefined || s.received >= s.max) {
            this.subscriptions.cancel(s);
        }
    }
    unsub(s, max) {
        if (!s || this.isClosed()) {
            return;
        }
        if (max) {
            this.sendCommand(`UNSUB ${s.sid} ${max}\r\n`);
        }
        else {
            this.sendCommand(`UNSUB ${s.sid}\r\n`);
        }
        s.max = max;
    }
    resub(s, subject) {
        if (!s || this.isClosed()) {
            return;
        }
        this.unsub(s);
        s.subject = subject;
        this.subscriptions.resub(s);
        // we don't auto-unsub here because we don't
        // really know "processed"
        this._sub(s);
    }
    flush(p) {
        if (!p) {
            p = (0, util_1.deferred)();
        }
        this.pongs.push(p);
        this.outbound.fill(PING_CMD);
        this.flushPending();
        return p;
    }
    sendSubscriptions() {
        const cmds = [];
        this.subscriptions.all().forEach((s) => {
            const sub = s;
            if (sub.queue) {
                cmds.push(`SUB ${sub.subject} ${sub.queue} ${sub.sid}${transport_1.CR_LF}`);
            }
            else {
                cmds.push(`SUB ${sub.subject} ${sub.sid}${transport_1.CR_LF}`);
            }
        });
        if (cmds.length) {
            this.transport.send((0, encoders_1.encode)(cmds.join("")));
        }
    }
    async close(err) {
        if (this._closed) {
            return;
        }
        this.whyClosed = new Error("close trace").stack || "";
        this.heartbeats.cancel();
        if (this.connectError) {
            this.connectError(err);
            this.connectError = undefined;
        }
        this.muxSubscriptions.close();
        this.subscriptions.close();
        const proms = [];
        for (let i = 0; i < this.listeners.length; i++) {
            const qi = this.listeners[i];
            if (qi) {
                qi.stop();
                proms.push(qi.iterClosed);
            }
        }
        if (proms.length) {
            await Promise.all(proms);
        }
        this._closed = true;
        await this.transport.close(err);
        this.raceTimer?.cancel();
        this.dialDelay?.cancel();
        this.closed.resolve(err);
    }
    isClosed() {
        return this._closed;
    }
    async drain() {
        const subs = this.subscriptions.all();
        const promises = [];
        subs.forEach((sub) => {
            promises.push(sub.drain());
        });
        try {
            await Promise.allSettled(promises);
        }
        catch {
            // nothing we can do here
        }
        finally {
            this.noMorePublishing = true;
            await this.flush();
        }
        return this.close();
    }
    flushPending() {
        if (!this.infoReceived || !this.connected) {
            return;
        }
        if (this.outbound.size()) {
            const d = this.outbound.drain();
            this.transport.send(d);
        }
    }
    initMux() {
        const mux = this.subscriptions.getMux();
        if (!mux) {
            const inbox = this.muxSubscriptions.init(this.options.inboxPrefix);
            // dot is already part of mux
            const sub = new SubscriptionImpl(this, `${inbox}*`);
            sub.callback = this.muxSubscriptions.dispatcher();
            this.subscriptions.setMux(sub);
            this.subscribe(sub);
        }
    }
    selectServer() {
        const server = this.servers.selectServer();
        if (server === undefined) {
            return undefined;
        }
        // Place in client context.
        this.server = server;
        return this.server;
    }
    getServer() {
        return this.server;
    }
}
exports.ProtocolHandler = ProtocolHandler;
//# sourceMappingURL=protocol.js.map