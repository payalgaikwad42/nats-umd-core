"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MuxSubscription = void 0;
const core_1 = require("./core");
const errors_1 = require("./errors");
class MuxSubscription {
    baseInbox;
    reqs;
    constructor() {
        this.reqs = new Map();
    }
    size() {
        return this.reqs.size;
    }
    init(prefix) {
        this.baseInbox = `${(0, core_1.createInbox)(prefix)}.`;
        return this.baseInbox;
    }
    add(r) {
        if (!isNaN(r.received)) {
            r.received = 0;
        }
        this.reqs.set(r.token, r);
    }
    get(token) {
        return this.reqs.get(token);
    }
    cancel(r) {
        this.reqs.delete(r.token);
    }
    getToken(m) {
        const s = m.subject || "";
        if (s.indexOf(this.baseInbox) === 0) {
            return s.substring(this.baseInbox.length);
        }
        return null;
    }
    all() {
        return Array.from(this.reqs.values());
    }
    handleError(isMuxPermissionError, err) {
        if (isMuxPermissionError) {
            // one or more requests queued but mux cannot process them
            this.all().forEach((r) => {
                r.resolver(err, {});
            });
            return true;
        }
        if (err.operation === "publish") {
            const req = this.all().find((s) => {
                return s.requestSubject === err.subject;
            });
            if (req) {
                req.resolver(err, {});
                return true;
            }
        }
        return false;
    }
    dispatcher() {
        return (err, m) => {
            const token = this.getToken(m);
            if (token) {
                const r = this.get(token);
                if (r) {
                    if (err === null) {
                        err = (m?.data?.length === 0 && m.headers?.code === 503)
                            ? new errors_1.NoRespondersError(r.requestSubject)
                            : null;
                    }
                    r.resolver(err, m);
                }
            }
        };
    }
    close() {
        const err = new errors_1.RequestError("connection closed");
        this.reqs.forEach((req) => {
            req.resolver(err, {});
        });
    }
}
exports.MuxSubscription = MuxSubscription;
//# sourceMappingURL=muxsubscription.js.map