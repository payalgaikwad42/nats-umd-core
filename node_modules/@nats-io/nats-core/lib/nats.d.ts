import { ProtocolHandler } from "./protocol";
import type { Features, SemVer } from "./semver";
import type { ConnectionClosedListener, ConnectionOptions, Context, Msg, NatsConnection, Payload, PublishOptions, QueuedIterator, RequestManyOptions, RequestOptions, ServerInfo, Stats, Status, Subscription, SubscriptionOptions } from "./core";
export declare class NatsConnectionImpl implements NatsConnection {
    options: ConnectionOptions;
    protocol: ProtocolHandler;
    draining: boolean;
    closeListeners?: CloseListeners;
    private constructor();
    static connect(opts?: ConnectionOptions): Promise<NatsConnection>;
    closed(): Promise<void | Error>;
    close(): Promise<void>;
    _check(subject: string, sub: boolean, pub: boolean): void;
    publish(subject: string, data?: Payload, options?: PublishOptions): void;
    publishMessage(msg: Msg): void;
    respondMessage(msg: Msg): boolean;
    subscribe(subject: string, opts?: SubscriptionOptions): Subscription;
    _resub(s: Subscription, subject: string, max?: number): void;
    requestMany(subject: string, data?: Payload, opts?: Partial<RequestManyOptions>): Promise<QueuedIterator<Msg>>;
    request(subject: string, data?: Payload, opts?: RequestOptions): Promise<Msg>;
    /** *
     * Flushes to the server. Promise resolves when round-trip completes.
     * @returns {Promise<void>}
     */
    flush(): Promise<void>;
    drain(): Promise<void>;
    isClosed(): boolean;
    isDraining(): boolean;
    getServer(): string;
    status(): AsyncIterable<Status>;
    get info(): ServerInfo | undefined;
    context(): Promise<Context>;
    stats(): Stats;
    getServerVersion(): SemVer | undefined;
    rtt(): Promise<number>;
    get features(): Features;
    reconnect(): Promise<void>;
    addCloseListener(listener: ConnectionClosedListener): void;
    removeCloseListener(listener: ConnectionClosedListener): void;
}
declare class CloseListeners {
    listeners: ConnectionClosedListener[];
    constructor(closed: Promise<void | Error>);
    add(listener: ConnectionClosedListener): void;
    remove(listener: ConnectionClosedListener): void;
    notify(err: void | Error): void;
}
export {};
