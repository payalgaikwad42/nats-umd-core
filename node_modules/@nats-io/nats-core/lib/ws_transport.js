"use strict";
/*
 * Copyright 2020-2024 The NATS Authors
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.WsTransport = void 0;
exports.wsUrlParseFn = wsUrlParseFn;
exports.wsconnect = wsconnect;
const util_1 = require("./util");
const transport_1 = require("./transport");
const options_1 = require("./options");
const databuffer_1 = require("./databuffer");
const protocol_1 = require("./protocol");
const nats_1 = require("./nats");
const version_1 = require("./version");
const errors_1 = require("./errors");
const VERSION = version_1.version;
const LANG = "nats.ws";
class WsTransport {
    version;
    lang;
    closeError;
    connected;
    done;
    // @ts-ignore: expecting global WebSocket
    socket;
    options;
    socketClosed;
    encrypted;
    peeked;
    yields;
    signal;
    closedNotification;
    constructor() {
        this.version = VERSION;
        this.lang = LANG;
        this.connected = false;
        this.done = false;
        this.socketClosed = false;
        this.encrypted = false;
        this.peeked = false;
        this.yields = [];
        this.signal = (0, util_1.deferred)();
        this.closedNotification = (0, util_1.deferred)();
    }
    async connect(server, options) {
        const connected = false;
        const ok = (0, util_1.deferred)();
        this.options = options;
        const u = server.src;
        if (options.wsFactory) {
            const { socket, encrypted } = await options.wsFactory(server.src, options);
            this.socket = socket;
            this.encrypted = encrypted;
        }
        else {
            this.encrypted = u.indexOf("wss://") === 0;
            this.socket = new WebSocket(u);
        }
        this.socket.binaryType = "arraybuffer";
        this.socket.onopen = () => {
            if (this.done) {
                this._closed(new Error("aborted"));
            }
            // we don't do anything here...
        };
        this.socket.onmessage = (me) => {
            if (this.done) {
                return;
            }
            this.yields.push(new Uint8Array(me.data));
            if (this.peeked) {
                this.signal.resolve();
                return;
            }
            const t = databuffer_1.DataBuffer.concat(...this.yields);
            const pm = (0, transport_1.extractProtocolMessage)(t);
            if (pm !== "") {
                const m = protocol_1.INFO.exec(pm);
                if (!m) {
                    if (options.debug) {
                        console.error("!!!", (0, util_1.render)(t));
                    }
                    ok.reject(new Error("unexpected response from server"));
                    return;
                }
                try {
                    const info = JSON.parse(m[1]);
                    (0, options_1.checkOptions)(info, this.options);
                    this.peeked = true;
                    this.connected = true;
                    this.signal.resolve();
                    ok.resolve();
                }
                catch (err) {
                    ok.reject(err);
                    return;
                }
            }
        };
        // @ts-ignore: CloseEvent is provided in browsers
        this.socket.onclose = (evt) => {
            let reason;
            if (!evt.wasClean && evt.reason !== "") {
                reason = new Error(evt.reason);
            }
            this._closed(reason);
            this._cleanup();
        };
        // @ts-ignore: signature can be any
        this.socket.onerror = (e) => {
            if (this.done) {
                return;
            }
            const evt = e;
            const err = new errors_1.errors.ConnectionError(evt.message);
            if (!connected) {
                ok.reject(err);
            }
            else {
                this._closed(err);
            }
            this._cleanup();
        };
        return ok;
    }
    _cleanup() {
        if (this.socketClosed === false) {
            // node seems to not emit closed if there's an error
            // all other runtimes do.
            this.socketClosed = true;
            this.socket.onopen = null;
            this.socket.onmessage = null;
            this.socket.onerror = null;
            this.socket.onclose = null;
            this.closedNotification.resolve(this.closeError);
        }
    }
    disconnect() {
        this._closed(undefined, true);
    }
    async _closed(err, _internal = true) {
        if (this.done) {
            try {
                this.socket.close();
            }
            catch (_) {
                // nothing
            }
            return;
        }
        this.closeError = err;
        if (!err) {
            while (!this.socketClosed && this.socket.bufferedAmount > 0) {
                await (0, util_1.delay)(100);
            }
        }
        this.done = true;
        try {
            this.socket.close();
        }
        catch (_) {
            // ignore this
        }
        return this.closedNotification;
    }
    get isClosed() {
        return this.done;
    }
    [Symbol.asyncIterator]() {
        return this.iterate();
    }
    async *iterate() {
        while (true) {
            if (this.done) {
                return;
            }
            if (this.yields.length === 0) {
                await this.signal;
            }
            const yields = this.yields;
            this.yields = [];
            for (let i = 0; i < yields.length; i++) {
                if (this.options.debug) {
                    console.info(`> ${(0, util_1.render)(yields[i])}`);
                }
                yield yields[i];
            }
            // yielding could have paused and microtask
            // could have added messages. Prevent allocations
            // if possible
            if (this.done) {
                break;
            }
            else if (this.yields.length === 0) {
                yields.length = 0;
                this.yields = yields;
                this.signal = (0, util_1.deferred)();
            }
        }
    }
    isEncrypted() {
        return this.connected && this.encrypted;
    }
    send(frame) {
        if (this.done) {
            return;
        }
        try {
            this.socket.send(frame.buffer);
            if (this.options.debug) {
                console.info(`< ${(0, util_1.render)(frame)}`);
            }
            return;
        }
        catch (err) {
            // we ignore write errors because client will
            // fail on a read or when the heartbeat timer
            // detects a stale connection
            if (this.options.debug) {
                console.error(`!!! ${(0, util_1.render)(frame)}: ${err}`);
            }
        }
    }
    close(err) {
        return this._closed(err, false);
    }
    closed() {
        return this.closedNotification;
    }
    // this is to allow a force discard on a connection
    // if the connection fails during the handshake protocol.
    // Firefox for example, will keep connections going,
    // so eventually if it succeeds, the client will have
    // an additional transport running. With this
    discard() {
        this.socket?.close();
    }
}
exports.WsTransport = WsTransport;
function wsUrlParseFn(u, encrypted) {
    const ut = /^(.*:\/\/)(.*)/;
    if (!ut.test(u)) {
        // if we have no hint to encrypted and no protocol, assume encrypted
        // else we fix the url from the update to match
        if (typeof encrypted === "boolean") {
            u = `${encrypted === true ? "https" : "http"}://${u}`;
        }
        else {
            u = `https://${u}`;
        }
    }
    let url = new URL(u);
    const srcProto = url.protocol.toLowerCase();
    if (srcProto === "ws:") {
        encrypted = false;
    }
    if (srcProto === "wss:") {
        encrypted = true;
    }
    if (srcProto !== "https:" && srcProto !== "http") {
        u = u.replace(/^(.*:\/\/)(.*)/gm, "$2");
        url = new URL(`http://${u}`);
    }
    let protocol;
    let port;
    const host = url.hostname;
    const path = url.pathname;
    const search = url.search || "";
    switch (srcProto) {
        case "http:":
        case "ws:":
        case "nats:":
            port = url.port || "80";
            protocol = "ws:";
            break;
        case "https:":
        case "wss:":
        case "tls:":
            port = url.port || "443";
            protocol = "wss:";
            break;
        default:
            port = url.port || encrypted === true ? "443" : "80";
            protocol = encrypted === true ? "wss:" : "ws:";
            break;
    }
    return `${protocol}//${host}:${port}${path}${search}`;
}
function wsconnect(opts = {}) {
    (0, transport_1.setTransportFactory)({
        defaultPort: 443,
        urlParseFn: wsUrlParseFn,
        factory: () => {
            if (opts.tls) {
                throw errors_1.InvalidArgumentError.format("tls", "is not configurable on w3c websocket connections");
            }
            return new WsTransport();
        },
    });
    return nats_1.NatsConnectionImpl.connect(opts);
}
//# sourceMappingURL=ws_transport.js.map